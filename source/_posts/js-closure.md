---
title: 浅谈 JavaScript 闭包
date: 2018-01-12
tags:
- JavaScript
- Web
categories: 技术栈
thumbnail: https://meto.chinakook.com/blog-images/180112.jpeg
---

相信学习 JavaScript 的同学都知道「**闭包(Closure)**」<!--more-->，这个概念在 JavaScript 中是非常重要的，并且在大多数人看来闭包是非常难以理解的概念。既然这样，那今天就带大家一起来看看这到底是何方神圣。

维基百科是这样解释的：

> 闭包，又称词法闭包或函数闭包，是引用了自由变量的函数，这个被引用的自由变量将和这个函数一同存在，即使离开了创造它的环境也不例外，所以，**闭包是由函数和与其相关的引用环境组合而成的实体**。

说了半天一句也没看懂，那我们来看看 JS 官方是怎么解释的：

> 闭包是指多个变量和绑定了这些变量的环境的表达式( 通常是一个函数 )，因而这些变量也是该表达式的一部分。

我去，这又是什么东西？**只看出闭包是个函数**，其他的还是一概不知。

既然这样不知道它们在说些什么，不如跟着我的思路来看一看到底是个什么。

要理解闭包，首先我们要弄明白什么是**词法作用域**和**作用域链**。

作用域一般有两种常见的模型，一种叫做**词法作用域**，另一种叫做**动态作用域**。我们的 JavaScript 就是基于词法作用域的语言。

简单来讲，**词法作用域就是一个变量的作用在出生(定义)时就已经被设定好了，当在本作用域中找不到变量时，就会一直向父作用域中去查找，直到直到为止**。如果不明白的话，看下面的代码大概就能理解了。

![](https://meto.chinakook.com/blog-images/%E4%BB%A3%E7%A0%811.png)

代码中 fun1 在其内部已经定义了变量 y，所以在查找 y 时在该作用域(内部函数 fun1 中)内可以找到，则无需再往父作用域中去查找；如果在其作用域内没有查找到，则会在父作用域内查找，也就是使用 fun 函数中的变量 y。

既然 JavaScript 中的函数和变量都有其作用域，那么作用域之间就会产生一条链，我们称之为**作用域链**。假设我们编写了一段 JS 代码，那这段代码就会有一个与之关联的作用域链。这个作用域链就是由全局对象(如：window)、我们自定义的对象(函数，局部变量)组成。比如上面的代码，其作用域链上是这样的：函数 fun1、变量 y ==> 函数 fun、变量 x、y ==> 全局对象。这就是所谓的**作用域链**。

理解了上面的内容，就可以来看看咱们今天的主人公「闭包」了。

**函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，也就是函数变量可以被藏在作用域链之内，这种特性在计算机科学文献中称为闭包**。看上去变量被“封闭包裹”了起来。由此可见，从理论上讲，所有的 JavaScript 函数全都是闭包的，因为它们都是对象，它们都关联在作用域链上。

那么怎么才能**显式**的形成闭包呢？先来看下面的例子。

![](https://meto.chinakook.com/blog-images/%E4%BB%A3%E7%A0%812.png)

注意这段代码中标记的地方：内部函数 fun1 在执行前通过外部函数被返回了，外部函数被赋值给了变量 result。这时，变量 result 的值就变成了函数 fun1，也就是说内部变量 name 在所属函数外部被调用了。我们来证实一下：

<center>![](https://meto.chinakook.com/blog-images/%E4%BB%A3%E7%A0%813.png)</center>

可以看到 result 的值就是函数 fun1，那为什么还可以读取变量 name 呢？答案就是 result 变成闭包了。

result 由两部分组成：**函数以及创建该函数的环境。函数就是被外部函数返回的内部函数，而环境就是由闭包创建时在作用域中的任何局部变量组成的**。在我们的例子中，result 是一个闭包，由**函数 fun1 **和闭包创建时存在的「**"Google"**」字符串形成。

现在想想，维基百科说的好像就是这么回事：**闭包是由函数和与其相关的引用环境组合而成的实体**。这就解释了为什么可以读取变量 name 了，因为 result 引用的环境是 fun1 函数相关的引用环境，可以理解为： result 处在 fun1 所处的作用域链的位置，既然这样，那自然可以读取变量 name 了。

这就是闭包，现在看来也就是这么回事么，没什么难理解的。

既然已经理解了，那我们再来看一个例子(引用自廖雪峰老师的 JS 教程)：

![](https://meto.chinakook.com/blog-images/%E4%BB%A3%E7%A0%814.png)

这个例子中，每次循环，都创建了一个新的函数，然后，把创建的 3 个函数都添加到数组 arr 中返回了。

那么调用 f1() 、f2()、f3() 的结果是什么呢？不就是 1，4，9 吗? 不是。

<center>![](https://meto.chinakook.com/blog-images/%E4%BB%A3%E7%A0%815.png)</center>

你没看错，答案就是 16，全部都是！原因在于闭包 results 返回的数组中的函数引用了变量 i，但这个返回的数组中的函数并不是立刻执行的，等到执行时，它们所引用的变量 i 已经变成 4 了，所以结果为 16。还是没明白？上面我们说了，**闭包是由函数和其相关的引用环境组合而成的**，既然所处的环境还是在作用域链原来的位置，那么变量 i 就会在 for 循环的作用下变成 4，而到了你去调用闭包的时候，闭包引用的变量 i 的值自然为 4 了，所以结果自然就是 16 了。

这个例子要提醒大家的是：**返回的函数，不要引用任何循环变量和变量值后续会发生变化的变量**。这一点在使用闭包时一定要牢记。

还要说明的一点就是，**避免滥用闭包**。原因：使用闭包之后，闭包中函数所处的环境会一直存在，所以闭包会使得函数中的变量都被保存在内存中，不会被“垃圾回收机制”回收，进而内存消耗过大，造成网页性能下降。

最后，理解清楚作用域链的概念不但对掌握闭包非常重要，并且对其他知识点（比如 with 语句）同样很重要。



<br>ikook
2018.01.12